<?php

/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class RecurringInvoice extends BaseRecurringInvoice
{
  const DISABLED = 0;
  const FINISHED = 1;
  const ENABLED  = 2;
  const PENDING  = 3;
  
  public function setUp()
  {
    parent::setUp();
    
    $this->_table->removeColumn('draft');
    $this->_table->removeColumn('sent_by_email');
    $this->_table->removeColumn('number');
    $this->_table->removeColumn('recurring_invoice_id');
    $this->_table->removeColumn('issue_date');
    $this->_table->removeColumn('due_date');
  }
  
  public function __toString()
  {
    return $this->getSeries().($this->getCustomer());
  }
  
  /**
   * gets the number of invoices generated by this recurring
   *
   * @return int
   **/
  public function getOccurrences()
  {
    return count($this->getInvoices());
  }
  
  /**
   * returns the number of pending invoices
   *
   * @return integer
   **/
  public function countPendingInvoices()
  {
    return ($this->getMustOccurrences() - $this->getOccurrences());
  }
  
  /**
   * checks and sets the status
   *
   * @return RecurringInvoice  $this
   **/
  public function checkStatus()
  {
    $this->checkMustOccurrences();
    
    if(!$this->getEnabled())
    {
      $this->setStatus(RecurringInvoice::DISABLED);
    }
    else
    {
      if(($this->getMaxOccurrences() && $this->getOccurrences() >= $this->getMaxOccurrences())
              || ($this->getFinishingDate() 
                && $this->getLastExecutionDate() >= $this->getFinishingDate() 
                && $this->countPendingInvoices() <= 0))
      {
        $this->setStatus(RecurringInvoice::FINISHED);
      }
      else
      {
        if($this->countPendingInvoices() > 0)
        {
          $this->setStatus(RecurringInvoice::PENDING);
        }
        else
        {
          $this->setStatus(RecurringInvoice::ENABLED);
        }
      }
    }
    
    return $this;
  }
  
  public function getStatusString()
  {
    $status = null;
    switch($this->getStatus())
    {
      case RecurringInvoice::DISABLED:
        $status = 'disabled';
        break;
      case RecurringInvoice::FINISHED:
        $status = 'finished';
        break;
      case RecurringInvoice::PENDING:
        $status = 'pending';
        break;
      case RecurringInvoice::ENABLED:
        $status = 'enabled';
        break;
      default:
        $status = 'unknown';
        break;
    }
    
    return $status;
  }
  
  /**
   * checks and sets the number of invoices that should have 
   * been generated until $today
   *
   * @param sfDate the date until the function checks
   * @return void
   **/
  public function checkMustOccurrences(sfDate $today = null)
  {
    if(!$today) $today = new sfDate();
    $starting_date = new sfDate($this->getStartingDate());
    $finishing_date = new sfDate($this->getFinishingDate());
    
    if($today->cmp($starting_date) > 0) // if today is greater than starting_date
    {
      // check only until the finishing_date, or until today if finishing_date has not yet come
      $check_date = ($today->cmp($finishing_date) > 0) ? $finishing_date: $today;
      switch($this->getPeriodType())
      {
        case 'year':
          $unit = sfTime::YEAR;
          break;
        case 'month':
          $unit = sfTime::MONTH;
          break;
        case 'week':
          $unit = sfTime::WEEK;
          break;
        case 'day':
          $unit = sfTime::DAY;
          break;
      }
      $difference = $check_date->diff($starting_date, $unit);
      
      $must_occurrences = floor($difference / $this->getPeriod()) +1;

      // if there is a max_occurrences set and is greater, then set this as the must occurrences
      if ($this->getMaxOccurrences() && $must_occurrences > $this->getMaxOccurrences())
      {
        $must_occurrences = $this->getMaxOccurrences();
      }

      $this->setMustOccurrences($must_occurrences);
      
    }
    else
    {
      $this->setMustOccurrences(0);
    }
  }
  
  /**
   * Generates and saves an invoice based on this recurring
   *
   * @return Invoice
   **/
  public function generateInvoice()
  {
    $i = new Invoice();
    // Get Invoice column mapping and intersect with Recurring one
    // to remove non common columns. Unset id and type columns.
    
    $iKeys = array_flip(array_keys($i->getTable()->getColumns()));
    $data  = $this->toArray(false);
    unset($data['id'], $data['type'], $data['must_occurrences'], $data['created_at'], 
      $data['last_execution_date'], $data['occurrences']);
    $data  = array_intersect_key($data, $iKeys);
    
    // Add specific fields for Invoice and hydrate.
    $data  = array_merge($data, array(
      'recurring_invoice_id' => $this->getId(),
      'issue_date'           => sfDate::getInstance()->format('Y-m-d'),
      'due_date'             => sfDate::getInstance()->addDay($this->getDaysToDue())->format('Y-m-d'),
      'draft'                => false
      ));
    $i->fromArray($data);
    
    // Copy Items and taxes
    foreach ($this->Items as $item)
    {
      $iTmp = $item->copy(false);
      foreach ($item->Taxes as $tax)
      {
        $iTmp->Taxes[] = $tax;
      }
      $i->Items[] = $iTmp;
    }
    // copy tags
    foreach ($this->getTags() as $tag)
    {
      $i->addTag($tag);
    }
    
    if($i->trySave())
    {
      $this->setLastExecutionDate(sfDate::getInstance()->format('Y-m-d'));
      $this->save();
    }
    
    return $i;
  }

}